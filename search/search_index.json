{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Eventum ASGI","text":"<p>Eventum ASGI is a simple WebSocket ASGI framework for Python.</p>"},{"location":"#description","title":"Description","text":"<p>Eventum ASGI is a lightweight, easy-to-use ASGI framework specifically designed for handling WebSocket connections. It provides a straightforward way to create WebSocket servers with event-based routing and middleware support.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>WebSocket connection handling</li> <li>Event-based routing</li> <li>Middleware support</li> <li>Lifespan event management</li> <li>Pydantic model validation for events and handhakes</li> <li>HTTP response support</li> <li>Connection flags management</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install Eventum ASGI using pip:</p> <pre><code>pip install eventum-asgi\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple example of how to use Eventum ASGI: <pre><code>from eventum_asgi import Eventum, WSConnection, Event\n\napp = Eventum()\n\n@app.handshake_route('/')\nasync def websocket_handler(connection: WSConnection):\n    await connection.accept()\n\n@app.event('user_registered')\nasync def message_handler(connection: WSConnection, event: dict):\n    await connection.send_text(f\"The event is: {event}\")\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre></p>"},{"location":"#handshake-routes","title":"Handshake Routes","text":"<p>Handshake routes are used to handle WebSocket handshakes. They are defined using the <code>handshake_route</code> decorator and are responsible for accepting the WebSocket connection and sending the handshake response as well adding a connection to the loop where the application is waiting for events to be sent by the client.</p> <pre><code>@app.handshake_route('/')\nasync def websocket_handler(connection: WSConnection):\n    await connection.accept()\n</code></pre>"},{"location":"#event-routes","title":"Event Routes","text":"<p>Event routes are used to handle events sent by the client. They are defined using the <code>event</code> decorator and are responsible for handling the event and sending a response back to the client(optinal). All the events should be defined and send as JSON objects and contain an event name.</p>"},{"location":"#json","title":"JSON","text":"<pre><code>{\n    \"event\": \"user_registered\",\n    \"data\": {\n        \"username\": \"johndoe\",\n        \"email\": \"johndoe@example.com\",\n        \"password\": \"password123\"\n    }\n}\n</code></pre>"},{"location":"#event-decorator","title":"Event decorator","text":"<pre><code>@app.event('user_registered')\nasync def message_handler(connection: WSConnection, event: dict):\n    await connection.send_text(f\"The event is: {event}\")\n</code></pre>"},{"location":"additional-features/http-exceptions/","title":"HTTP Exceptions","text":"<p>Sometimes you may need to send an HTTP exception to the client. You can use the <code>HttpException</code> class to do this. You can import this class from <code>eventum_asgi.exceptions</code>. Here's an example of how to use it:</p> <pre><code>from eventum_asgi.exceptions import HttpException\nfrom eventum_asgi.models import Headers\n@app.handshake_route('/')\nasync def websocket_handler(connection: WSConnection):\n   raise HttpException(status_code=400, headers=Headers({'X-Custom-Header': 'value'}), body=b'Bad Request')\n</code></pre>"},{"location":"additional-features/http-exceptions/#built-in-http-exceptions","title":"Built-in HTTP Exceptions","text":"<p>Some of the these exceptions are built-in and app raises them automatically.</p>"},{"location":"additional-features/http-exceptions/#not-found","title":"Not Found","text":"<p><code>HttpNotFoundException</code> exception is raised when the requested resource is not found it sends <code>404 Not Found</code>. If client makes a request to a non-existent resource, the server should respond with this exception. The connection will be closed after sending the response. </p>"},{"location":"additional-features/http-exceptions/#headers-missing","title":"Headers Missing","text":"<p><code>RequiredHeadersMissingException</code> exception is raised when the client sends a request without the required headers when you specified them in the <code>required_headers</code> parameter of the <code>handshake_route</code> decorator or <code>add_handshake_route</code> method. The connection will be closed after sending the response. It sends <code>400 Bad Request</code> HTTP status code.</p>"},{"location":"core-concepts/event-routing/","title":"Event Routing","text":"<p>Event routing is a core concept of Eventum ASGI that allows you to route events to different handlers. It's based on JSON format and is used to get messages from a client. Each JSON client event should contain a 'event' field as one of the keys. You can use the JSON bellow as an example:</p> <pre><code>{\n    \"event\": \"registered\",\n    \"user_id\": 1234\n    \"username\": \"John Doe\"\n    \"email\": \"john.doe@example.com\"\n}\n</code></pre> <p>The sturcture of the JSON object is completely up to you, the only important thing is that the 'event' field must be present in the JSON object. But you can structure it in any way you want for example:</p> <pre><code>{\n    \"event\": \"registered\",\n    \"user\": {\n        \"id\": 1234,\n        \"username\": \"John Doe\",\n        \"email\": \"john.doe@example.com\"\n    }\n}\n</code></pre>"},{"location":"core-concepts/event-routing/#decorator","title":"Decorator","text":"<p>Similar to the handshake router, the decorator <code>event</code> is used to create a router for the events. It accepts a <code>event</code> and <code>validator</code> as parameters. The <code>event</code> parameter is a string that specifies the event that the client must send in JSON object, while the <code>validator</code> parameter should be an instance of <code>Event</code> class which itself inherits from Pydantic's <code>BaseModel</code> class. You can simply import the <code>Event</code> class like that <code>from eventum_asgi import Event</code>. <code>validator</code> parameter is optional.</p> <pre><code>from eventum_asgi import Eventum, Event, WSConnection\n\napp = Eventum()\n\nclass RegistrationValidator(Event):\n    user_id: int\n    username: str\n    email: str\n\n@app.handshake_route(path='/', required_headers=['X-Custom-Header', 'X-Another-Header'])\nasync def websocket_handler(connection: WSConnection):\n    await connection.accept()\n\n@app.event(event='registered', validator=Event)\nasync def registered_handler(connection: WSConnection, event: dict):\n    await connection.send_text({'message': 'Welcome to the server!'})\n</code></pre>"},{"location":"core-concepts/event-routing/#function","title":"Function","text":"<p><code>add_event</code> function works the same way as the decorator <code>event</code> but it accepts a <code>handler</code> parameter that is a coroutine function that will be called when the event is received.</p> <pre><code>from eventum_asgi import Eventum, Event, WSConnection\n\napp = Eventum()\n\nclass RegistrationValidator(Event):\n    user_id: int\n    username: str\n    email: str\n\ndef registered_handler(connection: WSConnection, event: dict):\n    await connection.send_text({'message': 'Welcome to the server!'})\n\napp.add_event(event='registered', validator=Event, handler=registered_handler)\n</code></pre>"},{"location":"core-concepts/handshake-routing/","title":"Handshake Routing","text":"<p>Handshake routing is yet another core concept of Eventum ASGI as well as a starting point for each connection. To create a router you can either use a decorator <code>handshake_route</code> or a function  <code>add_handshake_route</code>. You can access both from the <code>Eventum</code> class e.g. <code>Eventum.handshake_route</code> or <code>Eventum.add_handshake_route</code>. </p>"},{"location":"core-concepts/handshake-routing/#decorator","title":"Decorator","text":"<p>The decorator <code>handshake_route</code> is used to create a router for the handshake request. It accepts a <code>path</code> as a parameter and <code>required_headers</code> as an optional parameter that specifies the headers that the client must send in the handshake request, it has to be a list of strings.</p> <pre><code>from eventum_asgi import Eventum\nfrom eventum_asgi.models import WSConnection\napp = Eventum()\n\n@app.handshake_route(path='/', required_headers=['X-Custom-Header', 'X-Another-Header'])\nasync def websocket_handler(connection: WSConnection):\n    await connection.accept()\n</code></pre>"},{"location":"core-concepts/handshake-routing/#function","title":"Function","text":"<p>The function <code>add_handshake_route</code> is used to create a router for the handshake request. It accepts a <code>path</code> as a parameter and <code>required_headers</code> as an optional parameter that specifies the headers that the client must send in the handshake request, it has to be a list of strings. Additionally, it accepts a <code>handler</code> parameter that is a coroutine function that will be called when the handshake request is received.</p> <pre><code>from eventum_asgi import Eventum\nfrom eventum_asgi.models import WSConnection\napp = Eventum()\n\ndef websocket_handler(connection: WSConnection):\n    await connection.accept()\n\napp.add_handshake_route(path='/', required_headers=['X-Custom-Header', 'X-Another-Header'], handler=websocket_handler)\n</code></pre> <p>Note</p> <p>Don't forget that the function you are passing to <code>add_handshake_route</code> or decorating with <code>handshake_route</code>  must be a coroutine function and must contain the <code>connection</code> parameter which is of type <code>WSConnection</code>.</p>"},{"location":"core-concepts/lifespan-events/","title":"Lifespan Events","text":"<p>Lifespan events are aplication level events which you can trigger <code>on_startup</code> and <code>on_shutdown</code>. These events are useful for performing tasks like starting and stopping background tasks, initializing databases, or sending notifications to external services.</p>"},{"location":"core-concepts/lifespan-events/#starup-event","title":"Starup event","text":"<p>The <code>on_startup</code> event is triggered when the application is starting. You can simply create it this way:</p> <pre><code>app = Eventum()\n\n@app.lifespan_event('on_startup')\nasync def startup():\n    print('Application is starting...')\n</code></pre>"},{"location":"core-concepts/lifespan-events/#shutdown-event","title":"Shutdown event","text":"<p>The <code>on_shutdown</code> event is triggered when the application is shutting down. Here's an example of how to use it:</p> <pre><code>app = Eventum()\n\n@app.lifespan_event('on_shutdown')\nasync def shutdown():\n    print('Application is shutting down...')\n</code></pre>"},{"location":"core-concepts/middleware/","title":"Middleware","text":"<p>Eventum ASGI provides a simple and flexible way to add middleware to your application. In the context of our framemwork Middleware is only used when handhake route is called. There some middlewares that are already included in the framework.</p>"},{"location":"core-concepts/middleware/#built-in-middleware","title":"Built-in Middleware","text":""},{"location":"core-concepts/middleware/#exceptionmiddleware","title":"ExceptionMiddleware","text":"<p><code>ExceptionMiddleware</code> is a middleware that catches exceptions raised during the execution of the application and sends a response back to the client with the appropriate status code and message. Used when you purposely raise an <code>HttpException</code>.</p>"},{"location":"core-concepts/middleware/#servererrormiddleware","title":"ServerErrorMiddleware","text":"<p><code>ServerErrorMiddleware</code> signals that something went wrong from the server side. It also prints a traceback to the console.</p>"},{"location":"core-concepts/middleware/#custom-middleware","title":"Custom Middleware","text":"<p>Middleware can be added to the application by using the <code>add_middleware</code> method. The middleware itself should inherit from the <code>MiddlewareClass</code> class which you can import from <code>eventum_asgi.middleware</code>. Here is an example of a custom middleware and the minimum pattern you should follow:</p> <pre><code>from eventum_asgi.middleware import MiddlewareClass\n\nclass CustomMiddleware(MiddlewareClass):\n    def __init__(self, call_next: Union[CallNext[WSConnection], MiddlewareClass[WSConnection]],\n                 *args: Any, **kwargs: Any) -&gt; None:\n        self.call_next = call_next\n\n    async def __call__(self, connection: WSConnection) -&gt; None:\n        await self.call_next(connection)\n</code></pre>"},{"location":"core-concepts/websocket-connections/","title":"WebSocket Connections","text":"<p>Eventum ASGI provides a simple way to handle WebSocket connections throght the <code>WSConnection</code> class. This class is responsible for managing the WebSocket connection and provides methods for sending and receiving data.</p>"},{"location":"core-concepts/websocket-connections/#accepting-a-connection","title":"Accepting a Connection","text":"<p>To accept the WebSocket connection, you need to call the <code>accept</code> method on the <code>WSConnection</code> instance. This method will initiate the WebSocket handshake and send the handshake response to the client.</p> <pre><code>@app.handshake_route('/')\nasync def websocket_handler(connection: WSConnection):\n    await connection.accept()\n</code></pre>"},{"location":"core-concepts/websocket-connections/#extra-headers","title":"Extra Headers","text":"<p>Additionally, you can pass an 'extra_headers' parameter to the <code>accept</code> method to add additional headers to the handshake response. You can either pass a dictionary or a 'Headers' class instance.</p>"},{"location":"core-concepts/websocket-connections/#headers-as-a-dictionary","title":"Headers as a dictionary","text":"<pre><code>@app.handshake_route('/')\nasync def websocket_handler(connection: WSConnection):\n    await connection.accept(extra_headers={'X-Custom-Header': 'value'})\n</code></pre>"},{"location":"core-concepts/websocket-connections/#headers-as-a-headers-class-instance","title":"Headers as a Headers class instance","text":"<pre><code>from eventum_asgi.models import Headers\n@app.handshake_route('/')\nasync def websocket_handler(connection: WSConnection):\n    headers = Headers({'X-Custom-Header': 'value'})\n    await connection.accept(extra_headers=headers)\n</code></pre>"},{"location":"core-concepts/websocket-connections/#subprotocols-factory","title":"Subprotocols factory","text":"<p>You can also pass a 'subprotocols_factory' function as a parameter to the <code>accept</code> method to specify a function that will be handle the subprotocols choice. Function should return a single value as a string and accepts a subprotocols list as a parameter. </p> <pre><code>def subprotocols_factory(subprotocols: list) -&gt; str:\n    return subprotocols[0]\n\n@app.handshake_route('/')\nasync def websocket_handler(connection: WSConnection):\n    await connection.accept(subprotocols_factory=subprotocols_factory)\n</code></pre>"},{"location":"core-concepts/websocket-connections/#sending-data","title":"Sending Data","text":"<p>Before diving futher into how to send and receive data it's important to learn the philosophy behind how Eventum ASGI handles WebSocket connections. The framework is maibly based on the concept of event-based routing. This means that most of the time you won't use methods like <code>receive_text</code>, <code>receive_bytes</code> or <code>receive_data</code> after you accepted a connection it gets into a loop and waits for an event to occur. Instead, you'll use the <code>send_text</code>, <code>send_bytes</code> methods to send data to the client directly from the event handlers.</p>"},{"location":"core-concepts/websocket-connections/#sending-text","title":"Sending Text","text":"<p>To send text data, you can use the <code>send_text</code> method. This method accepts a string as a parameter and sends it to the client.</p> <pre><code>@app.event('user_registered')\nasync def message_handler(connection: WSConnection, event: dict):\n    await connection.send_text('{\"event\": \"user_registered\", \"status\": \"success\"}')\n</code></pre>"},{"location":"core-concepts/websocket-connections/#sending-bytes","title":"Sending Bytes","text":"<p>To send bytes data, you can use the <code>send_bytes</code> method similarly to the <code>send_text</code> method. This method accepts a bytes-like object as a parameter and sends it to the client.</p> <pre><code>@app.event('user_registered')\nasync def message_handler(connection: WSConnection, event: dict):\n    await connection.send_bytes(b'{\"event\": \"user_registered\", \"status\": \"success\"}')\n</code></pre> <p>Note</p> <p>When you receive an event you can access the json data using the <code>event</code> parameter.</p>"},{"location":"core-concepts/websocket-connections/#sending-http-response","title":"Sending HTTP Response","text":"<p>Sometimes you may need to send an HTTP response to the client. You can use the <code>send_http_response</code> method to do this. This method accepts a <code>HttpResponse</code> object as a parameter and sends it to the client.</p> <pre><code>from eventum_asgi.http_eventum import HttpResponse\n\n@app.handshake_route('/')\nasync def websocket_handler(connection: WSConnection):\n    await connection.accept()\n    response = HttpResponse(status_code=200, headers={'Content-Type': 'text/plain'}, body='Hello, World!')\n    await connection.send_http_response(response)\n</code></pre>"},{"location":"core-concepts/websocket-connections/#closing-connections","title":"Closing Connections","text":"<p>Closing a connection is a crucial aspect of handling WebSocket connections. When client disconects, eventum-asgi will automatically close the connection. You can also close a connection manually using the <code>close</code> method. This method accepts an optional <code>code</code> parameter that specifies the close code, and an optional <code>reason</code> parameter that specifies the close reason.</p> <pre><code>from eventum_asgi import WSConnection, Eventum\n\napp = Eventum()\n\n@app.handshake_route('/')\nasync def websocket_handler(connection: WSConnection):\n    await connection.accept()\n    await connection.close(code=3000, reason='Test disconnect')\n</code></pre>"},{"location":"core-concepts/websocket-connections/#flags","title":"Flags","text":"<p>Flags is another core concept of <code>WSConnection</code> class. It's a dictionary for you to store any data you need to keep track of. You can use flags to store information about the connection, such as the user's session ID or any other data you need to access later. Can be useful for implementing features like authentication or authorization.</p>"},{"location":"core-concepts/websocket-connections/#adding-flags","title":"Adding Flags","text":"<p>You can set flags using the <code>add_flag</code> or 'add_flags' methods. The <code>add_flag</code> method accepts <code>name</code> and <code>value</code> as a parameters, while the <code>add_flags</code> method accepts a dictionary as a parameter.</p>"},{"location":"core-concepts/websocket-connections/#removing-flags","title":"Removing Flags","text":"<p>You can remove flags using the <code>remove_flag</code> or 'remove_flags' methods. The <code>remove_flag</code> method accepts <code>name</code> as a parameter, while the <code>remove_flags</code> method accepts a list of names as a parameter. There's also an option to clear all the flags using the <code>clear_flags</code> method.</p>"},{"location":"core-concepts/websocket-connections/#getting-flags","title":"Getting Flags","text":"<p>You can get flags using the <code>get_flag</code> or 'flags' methods. The <code>get_flag</code> method accepts <code>name</code> as a parameter and returns a specific flag, while the <code>flags</code> method returns a dictionary of all the flags.</p>"},{"location":"core-concepts/websocket-connections/#flags-usage-example","title":"Flags Usage Example","text":"<pre><code>@app.handshake_route('/')\nasync def websocket_handler(connection: WSConnection):\n    await connection.accept()\n    connection.add_flag('session_id', '123')\n    connection.add_flags({'some_data1': 'just_data1', 'some_data2': 'just_data2', 'some_data3': 'just_data3'})\n\n@app.event('profile_updated')\nasync def profile_handler(connection: WSConnection, event: dict):\n    if get_flag('session_id') == '123':\n        await connection.send_text('{\"event\": \"profile_updated\", \"status\": \"success\"}')\n        connection.remove_flag('some_data1')\n        print(connection.flags)\n    elif get_flag('session_id') == '456':\n        connection.clear_flags()\n    else:\n        connection.remove_flags(['some_data1', 'some_data2'])\n</code></pre>"}]}